{"ast":null,"code":"import { formatoMoneda } from \"./comun/format-moneda.function\";\nimport { limitNumber } from \"./comun/limit-number.function\";\nimport { maxMinNumber } from \"./comun/max-min-number.function\";\nimport * as i0 from \"@angular/core\";\nexport let DigitOnlyDirective = /*#__PURE__*/(() => {\n  class DigitOnlyDirective {\n    constructor(el) {\n      this.el = el;\n      this._hasDecimalPoint = false;\n      this._hasNegativeSign = false;\n      this._navigationKeys = ['Backspace', 'Delete', 'Tab', 'Escape', 'Enter', 'Home', 'End', 'ArrowLeft', 'ArrowRight', 'Clear', 'Copy', 'Paste'];\n      this.decimal = true;\n      this.decimalSeparator = \",\";\n      this.numberOfDecimals = 2;\n      this.numberOfIntegers = Infinity;\n      this.allowNegatives = false;\n      this.allowPaste = true;\n      this.negativeSign = \"-\";\n      this.min = -Infinity;\n      this.max = Infinity;\n      this.currency = \"\";\n      this.pattern = \"^\\\\d+(?:[,]\\\\d+)?$\";\n      this._regex = null;\n      this.inputElement = el.nativeElement;\n    }\n\n    ngOnChanges(changes) {\n      if (changes[\"pattern\"]) {\n        this._regex = this.pattern ? RegExp(this.pattern) : null;\n      }\n\n      if (changes[\"min\"]) {\n        const maybeMin = Number(this.min);\n        this.min = isNaN(maybeMin) ? -Infinity : maybeMin;\n      }\n\n      if (changes[\"max\"]) {\n        const maybeMax = Number(this.max);\n        this.max = isNaN(maybeMax) ? Infinity : maybeMax;\n      }\n    }\n\n    onBeforeInput(e) {\n      if (isNaN(Number(e.data))) {\n        if (e.data === this.decimalSeparator || e.data === this.negativeSign && this.allowNegatives) {\n          return; // go on\n        }\n\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n\n    onKeyDown(e) {\n      if (this._navigationKeys.indexOf(e.key) > -1 || // Allow: navigation keys: backspace, delete, arrows etc.\n      (e.key === \"a\" || e.code === \"KeyA\") && e.ctrlKey === true || // Allow: Ctrl+A\n      (e.key === \"c\" || e.code === \"KeyC\") && e.ctrlKey === true || // Allow: Ctrl+C\n      (e.key === \"v\" || e.code === \"KeyV\") && e.ctrlKey === true || // Allow: Ctrl+V\n      (e.key === \"x\" || e.code === \"KeyX\") && e.ctrlKey === true || // Allow: Ctrl+X\n      (e.key === \"a\" || e.code === \"KeyA\") && e.metaKey === true || // Allow: Cmd+A (Mac)\n      (e.key === \"c\" || e.code === \"KeyC\") && e.metaKey === true || // Allow: Cmd+C (Mac)\n      (e.key === \"v\" || e.code === \"KeyV\") && e.metaKey === true || // Allow: Cmd+V (Mac)\n      (e.key === \"x\" || e.code === \"KeyX\") && e.metaKey === true // Allow: Cmd+X (Mac)\n      ) {\n        // let it happen, don't do anything\n        return;\n      }\n\n      let newValue = \"\";\n\n      if (this.decimal && e.key === this.decimalSeparator) {\n        newValue = this.forecastValue(e.key);\n\n        if (newValue.split(this.decimalSeparator).length > 2) {\n          // has two or more decimal points\n          e.preventDefault();\n          return;\n        } else {\n          this._hasDecimalPoint = newValue.indexOf(this.decimalSeparator) > -1;\n          return; // Allow: only one decimal point\n        }\n      }\n\n      if (e.key === this.negativeSign && this.allowNegatives) {\n        newValue = this.forecastValue(e.key);\n\n        if (newValue.charAt(0) !== this.negativeSign || newValue.split(this.negativeSign).length > 2) {\n          e.preventDefault();\n          return;\n        } else {\n          this._hasNegativeSign = newValue.split(this.negativeSign).length > -1;\n          return;\n        }\n      } // Ensure that it is a number and stop the keypress\n\n\n      if (e.key === \" \" || isNaN(Number(e.key))) {\n        e.preventDefault();\n        return;\n      }\n\n      newValue = newValue || this.forecastValue(e.key); // check the input pattern RegExp\n\n      if (this._regex) {\n        if (!this._regex.test(newValue)) {\n          e.preventDefault();\n          return;\n        }\n      }\n\n      const newNumber = Number(newValue);\n\n      if (newNumber > this.max || newNumber < this.min) {\n        e.preventDefault();\n      }\n    }\n\n    onPaste(event) {\n      if (this.allowPaste === true) {\n        let pastedInput = \"\";\n\n        if (window[\"clipboardData\"]) {\n          // Browser is IE\n          pastedInput = window[\"clipboardData\"].getData(\"text\");\n        } else if (event.clipboardData && event.clipboardData.getData) {\n          // Other browsers\n          pastedInput = event.clipboardData.getData(\"text/plain\");\n        }\n\n        this.pasteData(pastedInput);\n        event.preventDefault();\n      } else {\n        // this prevents the paste\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    }\n\n    onDrop(event) {\n      var _a, _b;\n\n      const textData = (_b = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData(\"text\")) !== null && _b !== void 0 ? _b : \"\";\n      this.inputElement.focus();\n      this.pasteData(textData);\n      event.preventDefault();\n    }\n\n    onBlur(event) {\n      let textData = event.target.value;\n\n      if (!this.isNumeric(textData.replace(\"$\", \"\").replace(/\\./g, '').replace(\",\", \".\").trim())) {\n        this.inputElement.value = \"0\";\n        return;\n      }\n\n      textData = limitNumber({\n        value: textData,\n        limit: this.numberOfIntegers\n      });\n      textData = maxMinNumber({\n        value: textData,\n        decimales: this.numberOfDecimals,\n        min: this.min,\n        max: this.max\n      });\n      this.inputElement.value = formatoMoneda(parseFloat(textData.replace(\"$\", \"\").replace(/\\./g, '').replace(\",\", \".\").trim()), this.numberOfDecimals, this.currency);\n    }\n\n    onFocus(event) {\n      const textData = event.target.value;\n      this.inputElement.value = textData.replace(\"$\", \"\").replace(/\\./g, '').trim();\n    }\n\n    isNumeric(str) {\n      if (typeof str !== \"string\") return false; // we only process strings!\n\n      return !isNaN(parseFloat(str)); // ...and ensure strings of whitespace fail\n    }\n\n    pasteData(pastedContent) {\n      const sanitizedContent = this.sanitizeInput(pastedContent);\n\n      if (sanitizedContent.includes(this.negativeSign) && this._hasNegativeSign && !this.getSelection().includes(this.negativeSign)) {\n        return;\n      }\n\n      const pasted = document.execCommand(\"insertText\", false, sanitizedContent);\n\n      if (!pasted) {\n        if (this.inputElement.setRangeText) {\n          const {\n            selectionStart: start,\n            selectionEnd: end\n          } = this.inputElement;\n          this.inputElement.setRangeText(sanitizedContent, start !== null && start !== void 0 ? start : 0, end !== null && end !== void 0 ? end : 0, \"end\"); // Angular's Reactive Form relies on \"input\" event, but on Firefox, the setRangeText method doesn't trigger it\n          // so we have to trigger it ourself.\n\n          if (typeof window[\"InstallTrigger\"] !== \"undefined\") {\n            this.inputElement.dispatchEvent(new Event(\"input\", {\n              cancelable: true\n            }));\n          }\n        } else {\n          // Browser does not support setRangeText, e.g. IE\n          this.insertAtCursor(this.inputElement, sanitizedContent);\n        }\n      }\n\n      if (this.decimal) {\n        this._hasDecimalPoint = this.inputElement.value.indexOf(this.decimalSeparator) > -1;\n      }\n\n      this._hasNegativeSign = this.inputElement.value.indexOf(this.negativeSign) > -1;\n    } // The following 2 methods were added from the below article for browsers that do not support setRangeText\n    // https://stackoverflow.com/questions/11076975/how-to-insert-text-into-the-textarea-at-the-current-cursor-position\n\n\n    insertAtCursor(myField, myValue) {\n      var _a, _b;\n\n      const startPos = (_a = myField.selectionStart) !== null && _a !== void 0 ? _a : 0;\n      const endPos = (_b = myField.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n      myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);\n      const pos = startPos + myValue.length;\n      myField.focus();\n      myField.setSelectionRange(pos, pos);\n      this.triggerEvent(myField, \"input\");\n    }\n\n    triggerEvent(el, type) {\n      if (\"createEvent\" in document) {\n        // modern browsers, IE9+\n        const e = document.createEvent(\"HTMLEvents\");\n        e.initEvent(type, false, true);\n        el.dispatchEvent(e);\n      }\n    } // end stack overflow code\n\n\n    sanitizeInput(input) {\n      let result = \"\";\n      let regex;\n\n      if (this.decimal && this.isValidDecimal(input)) {\n        regex = new RegExp(`${this.getNegativeSignRegExp()}[^0-9${this.decimalSeparator}]`, \"g\");\n      } else {\n        regex = new RegExp(`${this.getNegativeSignRegExp()}[^0-9]`, \"g\");\n      }\n\n      result = input.replace(regex, \"\");\n      const maxLength = this.inputElement.maxLength;\n\n      if (maxLength > 0) {\n        // the input element has maxLength limit\n        const allowedLength = maxLength - this.inputElement.value.length + (result.includes(`${this.negativeSign}`) ? 1 : 0);\n        result = allowedLength > 0 ? result.substring(0, allowedLength) : \"\";\n      }\n\n      return result;\n    }\n\n    getNegativeSignRegExp() {\n      return this.allowNegatives && (!this._hasNegativeSign || this.getSelection().includes(this.negativeSign)) ? `(?!^${this.negativeSign})` : \"\";\n    }\n\n    isValidDecimal(string) {\n      if (!this._hasDecimalPoint) {\n        return string.split(this.decimalSeparator).length <= 2;\n      } else {\n        // the input element already has a decimal separator\n        const selectedText = this.getSelection();\n\n        if (selectedText && selectedText.indexOf(this.decimalSeparator) > -1) {\n          return string.split(this.decimalSeparator).length <= 2;\n        } else {\n          return string.indexOf(this.decimalSeparator) < 0;\n        }\n      }\n    }\n\n    getSelection() {\n      var _a, _b;\n\n      return this.inputElement.value.substring((_a = this.inputElement.selectionStart) !== null && _a !== void 0 ? _a : 0, (_b = this.inputElement.selectionEnd) !== null && _b !== void 0 ? _b : 0);\n    }\n\n    forecastValue(key) {\n      var _a, _b;\n\n      const selectionStart = (_a = this.inputElement.selectionStart) !== null && _a !== void 0 ? _a : 0;\n      const selectionEnd = (_b = this.inputElement.selectionEnd) !== null && _b !== void 0 ? _b : 0;\n      const oldValue = this.inputElement.value;\n      return oldValue.substring(0, selectionStart) + key + oldValue.substring(selectionEnd);\n    }\n\n  }\n\n  DigitOnlyDirective.ɵfac = function DigitOnlyDirective_Factory(t) {\n    return new (t || DigitOnlyDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  DigitOnlyDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n    type: DigitOnlyDirective,\n    selectors: [[\"\", \"phyDigitOnly\", \"\"]],\n    hostBindings: function DigitOnlyDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"beforeinput\", function DigitOnlyDirective_beforeinput_HostBindingHandler($event) {\n          return ctx.onBeforeInput($event);\n        })(\"keydown\", function DigitOnlyDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        })(\"paste\", function DigitOnlyDirective_paste_HostBindingHandler($event) {\n          return ctx.onPaste($event);\n        })(\"drop\", function DigitOnlyDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        })(\"blur\", function DigitOnlyDirective_blur_HostBindingHandler($event) {\n          return ctx.onBlur($event);\n        })(\"focus\", function DigitOnlyDirective_focus_HostBindingHandler($event) {\n          return ctx.onFocus($event);\n        });\n      }\n    },\n    inputs: {\n      decimal: \"decimal\",\n      decimalSeparator: \"decimalSeparator\",\n      numberOfDecimals: \"numberOfDecimals\",\n      numberOfIntegers: \"numberOfIntegers\",\n      allowNegatives: \"allowNegatives\",\n      allowPaste: \"allowPaste\",\n      negativeSign: \"negativeSign\",\n      min: \"min\",\n      max: \"max\",\n      currency: \"currency\",\n      pattern: \"pattern\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return DigitOnlyDirective;\n})();","map":null,"metadata":{},"sourceType":"module"}